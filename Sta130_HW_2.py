#!/usr/bin/env python
# coding: utf-8

# In[4]:


###1

#Part 1: Imports and setting up variables

import numpy as np
all_door_options = (1,2,3)  # tuple
my_door_choice = 1  # 1,2,3
i_won = 0
reps = 100000

# In this section, the code first imports NumPy for random selection. 
# It then defines three possible door choices (1, 2, 3) and sets the contestant's initial choice to door 1. 
# Additionally, the code initializes a counter for the number of wins (i_won) and sets the number of simulations to run (reps).

#Part 2: For loop over repetition

for i in range(reps):
    secret_winning_door = np.random.choice(all_door_options)

# Each iteration simulates one game.
# secret_winning_door: The randomly selected door where the prize is placed

#Part 3: Setting list operations for "Goat" doors

    all_door_options_list = list(all_door_options)
    all_door_options_list.remove(secret_winning_door)

# Part 4: Removing contestant's door
    try:
        all_door_options_list.remove(my_door_choice)
    except:
        pass

# This part of the code removes the contestant's initially chosen door from the list of non-winning doors. The 'try'/'except' block handles the case where the chosen door is the winning one, preventing an error.

# Part 5: Revealing a goat door

    goat_door_reveal = np.random.choice(all_door_options_list)
    all_door_options_list.remove(goat_door_reveal)
    
# This part of code randomly picks and removes a "goat" door (not the prize door), simulating the host revealing a losing door.

# Part 6 : Switching strategy

    if secret_winning_door != my_door_choice:
        all_door_options_list.append(secret_winning_door)
        
    my_door_choice = all_door_options_list[0]

# If the original choice was not the winning door, the winning door is added back to the list in this part of the code
# The contestant switches to the remaining door in all_door_options_list.

# Part 7: Checking if contestant won

    if my_door_choice == secret_winning_door:
        i_won += 1

# After switching, the program checks if the new choice is the winning door. If so, the win counter (i_won) is incremented

# Part 8: Calculating win probability

i_won / reps

# Finally, by dividing the number of wins (i_win) by the number of simulations (reps), we calculate the probability of winning, which is around 0.67




# In[3]:


###2

#Improved code:

import numpy as np

all_door_options = (1, 2, 3)  
reps = 100000  
wins = 0  


for _ in range(reps):
    winning_door = np.random.choice(all_door_options)  
    initial_choice = np.random.choice(all_door_options)  
    
  
    remaining_doors = [door for door in all_door_options if door != winning_door and door != initial_choice]
    revealed_goat_door = np.random.choice(remaining_doors)
    

    switched_choice = [door for door in all_door_options if door != initial_choice and door != revealed_goat_door][0]
    

    if switched_choice == winning_door:
        wins += 1

# Probability of winning by switching
wins / reps

# My preferences in terms of readibility between the original code and the code improvements suggested by the ChatBot:

# New Version:

# Simplified Structure: The new version is more concise, with fewer moving parts, making it easier to understand at a glance.
# List comprehensions for revealing and switching doors are clear and direct, reducing the mental load of following the logic.
# Random initial choice avoids hardcoding, making the logic more intuitive and flexible.


# Original Version:

# Detailed Breakdown: The original version shows each step of the process explicitly (like removing doors and adding back the winning door), making it clearer for someone learning how each part of the problem works.

# Error Handling Transparency: The use of a try-except block helps clarify the scenario where the initial choice matches the winning door, making the code understandable in that specific case


# In[3]:


###3

# My preferred verison of the code: the new version generated by chatbot

import numpy as np

# Setup parameters
all_door_options = (1, 2, 3)  # set available doors
reps = 100000  # number of repetitions
wins = 0  # counter for wins

# The game simulation loop
for _ in range(reps):
    winning_door = np.random.choice(all_door_options)  # random door with the prize
    initial_choice = np.random.choice(all_door_options)  # contestant's initial choice
    
    # Host reveals a losing door (goat door), not the winning door and not the contestant's choice
    remaining_doors = [door for door in all_door_options if door != winning_door and door != initial_choice]
    revealed_goat_door = np.random.choice(remaining_doors)
    
    # Switch to the remaining door
    switched_choice = [door for door in all_door_options if door != initial_choice and door != revealed_goat_door][0]
    
    # Check if switching wins
    if switched_choice == winning_door:
        wins += 1

# Probability of winning by switching
print(wins / reps)

    


# In[ ]:


### Chatbot Session Summary To This Point (Question 1,2,3):

# In this session, we worked through a Python implementation of the Monty Hall problem, starting with a detailed breakdown of the original simulation code. I explained each part of the code, including the logic behind selecting doors, revealing a goat (losing) door, and implementing the switch strategy. 

# Key points included:

# Random selection of the winning door.
# Handling door removal (especially with the contestant's and the host’s choices).
# Switching strategy and checking if switching leads to a win.

# Next, I (the chatbot) provided a more streamlined version of the code to improve clarity and simplify the simulation:

# Random initial choice of the door was added, instead of hardcoding the contestant's choice to door 1.
# List comprehensions were used to select and remove doors, reducing multiple steps and conditional checks.
# The new version avoided the try-except block, making the code easier to read and follow by removing unnecessary error handling.

# Lastly, we discussed which version was better for different purposes: 

# The new version being more suitable for quick understanding and readability, while the original version offered more detailed insights into the logic of the Monty Hall problem.

# In conclusion, we focused on improving the code for readability and explanation while maintaining the integrity of the Monte Hall problem simulation.


# In[2]:


###4

#I have added prompts for each part of the code to demonstrate my understanding after reading the chatbot’s explanation of this 'Markovian Chatbot' program.

# Markovian Chatbot

# from collections import defaultdict
# Uncommenting defaultdict can simplify the code, but we'll use regular dicts for now to see the explicit logic

# Dictionary to track how many times each word is used
word_used = dict()  # This keeps track of how often each word appears in the text.

# Dictionary to track what the next word is after a given word and how often that pairing occurs
next_word = dict()  # This will store for each word, a dictionary of the words that come after it and their counts.

# Loop through all words except the last one (because there is no next word for the last word)
for i, word in enumerate(words[:-1]):  # Loop through the words list, except the last word

    # If the word has been encountered before, increment its count in word_used
    if word in word_used:
        word_used[word] += 1  # If the word has been seen before, increase its count
    else:
        # Otherwise, initialize its count to 1 and set up a next_word dictionary for this word
        word_used[word] = 1  # First time seeing this word, set count to 1
        next_word[word] = {}  # Initialize an empty dictionary for the next word frequencies

    # Check if the next word (words[i+1]) is already in the next_word dictionary for the current word
    if words[i + 1] in next_word[word]:
        next_word[word][words[i + 1]] += 1  # If the next word is already in the dictionary, increment its count
    else:
        # Otherwise, initialize its count to 1
        next_word[word][words[i + 1]] = 1  # First time seeing this next word after the current word, set count to 1


# In[ ]:


### Chatbot's Session Summary for Question 4

# Session Summary:
# Code Explanation:

# You provided a Markovian chatbot code snippet that tracks word frequencies and word pair transitions.

# I (the chatbot) explained the functionality of each part of the code, including:

# The purpose of word_used and next_word dictionaries.
# How the for loop processes each word except the last one.
# How the code updates word counts and transitions between words.

# Detailed Breakdown:

# word_used tracks the frequency of each word.
# next_word tracks which words follow each word and how often.
# The loop updates these dictionaries as it iterates through the list of words.


# In[1]:


###5

##1

# Here is what my chatbot generates regarding the potential extensions of the Markovian chatbot: 

# from collections import defaultdict
word_used = dict()  # defaultdict(int)
next_word = dict()  # defaultdict(lambda: defaultdict(int))
for i, word in enumerate(words[:-1]):

    if word in word_used:
        word_used[word] += 1
    else:
        word_used[word] = 1
        next_word[word] = {}

    if words[i + 1] in next_word[word]:
        next_word[word][words[i + 1]] += 1
    else:
        next_word[word][words[i + 1]] = 1
        
# Potential Extensions or Alternatives:

#1.
# defaultdict (Commented Out)

# The commented-out from collections import defaultdict suggests that defaultdict could be used as an alternative to regular dictionaries.
# defaultdict(int): Creates a dictionary where any missing key returns 0 by default. This can simplify counting occurrences because you don't need to check if a key exists before updating its count.
# defaultdict(lambda: defaultdict(int)): Creates a nested dictionary where any missing key in the outer dictionary returns another defaultdict(int) by default. This would automatically handle missing keys in both word_used and next_word.

#2.
# Using defaultdict for word_used:

from collections import defaultdict
word_used = defaultdict(int)

# This would eliminate the need to check if word exists in word_used and manually increment its count. You could just do word_used[word] += 1.

#3.
# Using defaultdict for next_word:

next_word = defaultdict(lambda: defaultdict(int))

# This simplifies the nested dictionary handling. You wouldn't need to check if word is already in next_word before adding to it. Similarly, the inner dictionary for tracking next words would automatically handle new entries.



# In[ ]:


###5

##2

# The chatbot provided me with more detailed explanations of the code functions that I didn’t quite understand:

# defaultdict(int) simplifies counting as it automatically initializes any new key with 0.

# defaultdict(lambda: defaultdict(int)) handles nested dictionaries efficiently, eliminating the need to manually check for the existence of keys and initializing them.


# In[9]:


###5

##3

# It seems like the chatbot understand the extension i provide perfectly. Here is chatbot's explaintion:

## Code Breakdown

# 1. Imports and Dataset Processing:
 
    from collections import Counter, defaultdict
    characters = Counter("\n"+ avatar.character.str.upper().str.replace(' ','.')+":")
    
   #  `Counter` is used to create a frequency count of characters from the `avatar.character` column. 
   #  The column text is converted to uppercase, spaces are replaced with dots, and a newline character is prepended.

# 2. **Nested Dictionary Setup:
 
    nested_dict = lambda: defaultdict(nested_dict)
    word_used2C = nested_dict()
    next_word2C = nested_dict()
   
  # `nested_dict` creates a deeply nested `defaultdict` structure. This allows for hierarchical storage where missing keys are automatically initialized.

# 3. Processing Words and Updating Counts:

    for i, word in enumerate(words[:-2]):
        if word in characters:
            character = word

 # Iterates over `words` up to the second-to-last word. If the word is found in the `characters` Counter, it assigns it to `character`.

# 4. Updating `word_used2C`:
  
    if character not in word_used2C:
        word_used2C[character] = dict()
    if word+' '+words[i+1] not in word_used2C[character]:
        word_used2C[character][word+' '+words[i+1]] = 0
    word_used2C[character][word+' '+words[i+1]] += 1
 
   # For each character, it tracks how often pairs of words (`word` followed by `words[i+1]`) occur. It updates the count of these pairs in `word_used2C`.

# 5.Updating `next_word2C`:
    
    if character not in next_word2C:
        next_word2C[character] = dict()
    if word+' '+words[i+1] not in next_word2C[character]:
        next_word2C[character][word+' '+words[i+1]] = dict()
    if words[i+2] not in next_word2C[character][word+' '+words[i+1]]:
        next_word2C[character][word+' '+words[i+1]][words[i+2]] = 0
    next_word2C[character][word+' '+words[i+1]][words[i+2]] += 1

  # For each character, it tracks the frequency of sequences of three words (`word` followed by `words[i+1]`, followed by `words[i+2]`). This information is stored in `next_word2C`.

### Summary

# **Data Structure**: 
  # `word_used2C` keeps track of how often each two-word sequence occurs for each character.
  # `next_word2C` records the frequency of each possible next word given a two-word sequence for each character.

# **Purpose**:
  # This extension builds on the original Markovian model by adding context for different characters and considering sequences of three words, allowing for more detailed and character-specific predictions.

### Example Use Case

# If the `avatar.character` column contains character names and dialogue, this extension can be used to generate more contextually appropriate responses based on the character and the sequence of words in their dialogue. For instance, if analyzing Shakespearean characters, it might help in generating lines consistent with each character's speech patterns.


# In[ ]:


###6

##1

# Discuss how quickly the ChatBot was able to be helpful for each of the above questions, and if so, how?

# The chatbot is an excellent tool that quickly generates what users need, but only if they know what they are looking for. 
# Using my experience with the chatbot in this homework as an example, I can quickly get the code or explanations I want. 
# This is because I know what I am looking for, such as a simpler version of the 'Monte Hall' code and understanding the extension of the 'Markovian Chatbot' code.


# In[ ]:


###6

##2

# Discuss whether or not interacting with ChatBot to try to figure things out was frustrating or unhelpful, and if so, how?

# To me, interacting with the chatbot is not as frustrating or unhelpful as I initially thought it would be. 
# Using ###5 ##1 as an example, although I didn’t obtain the precise result I wanted, the chatbot still provided me with insightful ideas and examples that are very similar to the extension in the homework. 
# In comparison, the chatbot is a much superior option compared to tools like Google Search, which often don’t provide any useful information or results at all."


# In[ ]:


###6

##3

# Based on your experiences to date (e.g., including using ChatBots to troubleshoot coding errors in the previous homework), provide an overall assessment evaluating the usefulness of ChatBots as tools to help you understand code

# "My personal experiences with the chatbot while doing STA130 work have been quite positive so far. 
# When it comes to troubleshooting coding errors, although the chatbot often generates overly detailed explanations of the errors I made, it always identifies the errors correctly and provides a clear tutorial on how to fix them.
# Regarding providing explanations for code, the chatbot has never failed me. It always offers very detailed explanations for every single line of code. With its help, my journey of learning code has been easier and more straightforward.
# Overall, I would rate my STA130 learning experience with the chatbot a solid 9/10.


# In[ ]:


# Chatbot Session Summary on Question 5,6:

# Markov Chain Code Analysis:

# You provided code for a Markovian chatbot that tracks word frequencies and word transitions.
# We discussed how each part of the code works, including how word_used and next_word dictionaries are updated during the loop.

# Extensions with defaultdict:

# We explored how using defaultdict could simplify the code for counting word occurrences and transitions by automatically handling missing keys and initializing them.

# Character-Level Markov Chains:

# We discussed adapting the Markov chain model to work at the character level instead of the word level.
# We covered how to track character frequencies and transitions, and how this approach can be used for text generation and pattern recognition.

# Experience Summary:

# Your experience shows a strong understanding of Markov chains and Python data structures. You effectively explored and adapted code for both word-level and character-level models, demonstrating thoughtful analysis and problem-solving skills.

# The Explanation Of The Extension Model:

# The extended model adds character context, tracking more complex sequences (word pairs and triples) and leveraging character-specific data for improved context.



# In[ ]:


###7

# My perception of AI-driven assistance tools, like chatbots, has evolved significantly since I began my STA130 course. 
# Initially, I saw these tools as supplementary resources which are helpful but not essential. However, as I’ve engaged more deeply with coding, statistics, and data science, I've come to appreciate their value much more. 
# It comes down to 2 points which greatly improved my STA130 learning experience with the help of chatbot

# First, chatbots greatly increased working and learning efficiency. 
# Chatbots have streamlined my learning process. 
# They provide quick solutions to coding errors, clarify statistical concepts, and offer guidance on data analysis tasks. 

# Second, chatbots also provide personalized assistance which is what tools such as Google Search can't do. 
# The ability to receive tailored responses based on specific queries or issues is a major advantage of chatbot. 
# For example, when I working with datasets like Titanic and exploring Python simulations, the chatbot is a unique tool that can address my unique questions.
# This significantly enhanced my learning experience.


# In[ ]:


###8 


##1. 
# Start a new ChatBot session and discuss the relevance of learning and adaptability, communication, coding, and statistics and data analysis as skills in the modern world, especially with respect to career opportunities (particularly in the context of the data science industry)


# In the modern world, particularly within the data science industry, a combination of learning adaptability, communication, coding, and statistical analysis is crucial for success. 
# The ability to learn quickly and adapt to new tools and methods is essential, given the fast-paced evolution of technology. 
# This adaptability ensures professionals can stay current and integrate advanced techniques like machine learning into their work.

# Communication is equally important, as data scientists often need to explain complex concepts to non-technical audiences. 
# Clear communication helps transform raw data into actionable business insights, making it a vital skill for those aiming to influence decision-making.

# Coding is at the core of data science, with languages like Python, R, and SQL being indispensable for automating tasks, analyzing data, and building models.
# Proficiency in these areas not only boosts productivity but also expands career opportunities, from data analysis to machine learning engineering.

# Lastly, statistical and data analysis skills form the foundation of data science, allowing professionals to draw insights, validate models, and make data-driven predictions. 
# Employers value these abilities, as they are key to producing reliable insights and supporting evidence-based decisions.

# Together, these skills prepare individuals to excel in the data science field, opening up career advancement opportunities and allowing them to take on complex, impactful projects.


# In[ ]:


###8

##2. 
# See if ChatBot thinks you could be a statistician or data scientist without coding or doing data analysis, and then transition your ChatBot conversation into a career exploration discussion, using the ChatBot to identify the skills that might be the most valuable for a career that you're interested.

# First Question to Chatbot: 

# Do you think I could become a statistician or data scientist without coding or doing data analysis?

#Chatbot's responce:

# Becoming a statistician or data scientist without coding or performing data analysis would be very challenging, as both fields rely heavily on these skills.
# Coding is fundamental to modern data science because it allows you to automate tasks, manipulate large datasets, build statistical models, and work efficiently with tools and software used in the industry.
# Data analysis, meanwhile, is at the heart of both statistics and data science—it's how you derive insights, make predictions, and inform decisions.

# While it may be possible to contribute to a data team with a strong theoretical understanding of statistics or by specializing in other areas (such as consulting, communication, or managing data projects), the absence of hands-on coding and data analysis limits your role.
# Most employers in these fields expect professionals to have both coding proficiency and the ability to work directly with data.

# In short, coding and data analysis are integral parts of the job, and excelling in either data science or statistics without them would be difficult. 
# However, you could still focus on aspects like data strategy or communication, but these roles would likely be more managerial or advisory in nature.

# Second Question to Chatbot:

# To expand on this topic, what skills do you think are most valuable if I want to pursue a career focused on actuarial science and finance?

#Chatbot's reponce:

# For a career in actuarial science and finance, the most valuable skills include:

# 1. Mathematical and Statistical Expertise:
   # Actuarial science heavily relies on probability, statistics, and financial mathematics. You’ll need to be proficient in understanding and applying statistical models to assess risks, forecast outcomes, and make sound financial predictions. Mastering probability theory and stochastic processes is especially important in areas like insurance and pensions.

# 2. Financial Knowledge:
   # A deep understanding of financial theory, investment strategies, and markets is critical in this field. Actuaries often work with financial instruments like bonds, stocks, and derivatives, and they need to understand how these interact with risk management, pricing, and portfolio optimization.

# 3. Coding and Data Analysis:
   # Just like in data science, coding is becoming more critical in actuarial work. Tools like R, Python, and SAS are often used for data analysis, running simulations, and automating financial models. While the focus may be less on machine learning than in data science, programming skills enable actuaries to work efficiently with large datasets, create actuarial models, and assess financial risks.

# 4. Risk Management and Problem-Solving:
   # Actuaries assess risk and uncertainty. Being able to think critically and solve complex problems is key, whether it’s pricing an insurance product, evaluating a pension fund, or mitigating financial risk in investments.

# 5. **Communication:**
   # Like data scientists, actuaries need to explain technical results in a clear, accessible way to stakeholders. Whether advising businesses on risk management or explaining policy pricing to clients, being able to communicate financial risks and their implications is essential.

# 6. Regulatory Knowledge:
   # In finance and insurance, understanding regulations is crucial. Actuaries must be well-versed in legal standards and compliance requirements that govern insurance products, pension plans, and other financial instruments.

# 7. Business Acumen:
   # Having an understanding of business operations and strategy adds value to an actuarial role. Actuaries often provide insight into long-term financial planning and risk mitigation, which impacts a company’s overall strategy. 

# 8. Professional Certification:
   #For an actuary, certification is critical for career advancement. This means passing exams from bodies like the Society of Actuaries (SOA) or the Casualty Actuarial Society (CAS). These credentials demonstrate both competence and commitment to the profession.

# In summary, a combination of strong quantitative skills, financial knowledge, coding, communication, and business awareness is essential for success in actuarial science and finance. Each of these will help you navigate the complex, data-driven decisions that define these fields.



# In[ ]:


###8

##3. 
# Ask for a summary of this ChatBot session and paste it into your homework notebook 

# Chatbot's session summary for question 8: 

# In this session, we first explored the importance of learning adaptability, communication, coding, and statistics/data analysis as key skills in the data science industry.
# These skills are vital for staying competitive, translating technical insights to stakeholders, and efficiently handling data. 
# Then, we discussed whether it's possible to pursue a career as a statistician or data scientist without coding or data analysis, concluding that these skills are essential. 
# Lastly, we covered the most valuable skills for a career in actuarial science and finance, such as mathematical expertise, financial knowledge, coding, communication, and professional certification.


# In[ ]:


###8

##4.
# Paraphrase the assessments and conclusions of your conversation in the form of a reflection on your current thoughts regarding your potential future career(s) and how you can go about building the skills you need to pursue it

# Reflecting on my potential future career pursues, I realize that coding and data analysis are essential in both data science and actuarial science. 
# To stay competitive, I need to improve my skills in programming and data analysis, particularly in Python or R. In actuarial science and finance, building a strong foundation in math, statistics, and financial knowledge is crucial.
# Communication will also be key for explaining complex concepts to non-technical audiences.
# By focusing on certifications, developing these skills, and staying adaptable, I can confidently prepare for success in these fields.


# In[ ]:


###8

##5.
# Give your thoughts regarding the helpfulness or limitations of your conversation with a ChatBot, and describe the next steps you would take to pursue this conversation further if you felt the information the ChatBot provides was somewhat high level and general, and perhaps lacked the depth and detailed knowledge of a dedicated subject matter expert who had really take the time to understand the ins and outs of the industry and career path in question.

# The conversation with the chatBot has been helpful in providing a broad overview of the skills and knowledge needed for careers in data science and actuarial science. 
# However, it feels a bit high-level and lacks the in-depth insights I might get from a dedicated industry expert. 
# If I wanted to dive deeper, I’d explore specific areas like certification requirements, industry trends, or detailed case studies by consulting professionals in the field or seeking mentorship from actuaries or data scientists who have hands-on experience and can offer more tailored guidance.


# In[ ]:


###9

# Somewhat

